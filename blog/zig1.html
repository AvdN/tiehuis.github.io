<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="author" content="Marc Tiehuis">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>blog</title>
    <style>
html, body {
  font-family: sans-serif;
  font-size: small;
  line-height: 1.5;
}

h1, h2, h3 {
  margin-top: 2em;
}

h3, h4, h5 {
  color: #2d58b7;
}

h1:nth-of-type(1) {
  margin-top: 0.7em;
  margin-bottom: 0em;
  text-align: right;
}

.published {
  margin-bottom: 4em;
  text-align: right;
}

.post, .home {
  margin-left: auto;
  margin-right: auto;
}

.home-link {
  float:left;
  margin-top: 0.7em;
}

.footer {
  text-align: center;
  margin-top: 3em;
  margin-bottom: 1.5em;
}

pre > code {
  display: block;
  overflow: auto;
  padding: 0.3em;
}

code {
  background-color: snow;
  font-size: 13px;
}

@media screen and (min-width: 45em) {
  .post, .home, .central-element {
    width: 50em;
  }
}

@media screen and (max-width: 45em) {
  .post, .home, .central-element {
    width: 92%;
  }

  code {
    font-size: small;
  }
}
    </style>
  </head>
  <body>
    <div class="post">
      <div class="home-link"><a href="../index.html">home</a></div>
<h1>Iterative Replacement of C with Zig</h1>
<div class="published"><time>19 Jul 2017</time></div>
<p><a href="http://ziglang.org/">Zig</a> is a programming language in a similar realm as C.
Being more modern, it has a number of useful constructs such as sum types,
compile-time introspection, improved error handling and no preprocessor!</p>
<p>This post will not describe the language itself (check the project page for
that), but will show how it can be
used to convert an existing C code-base into zig. We will look at a simplistic
example, but the general strategy remains the same.</p>
<p>The <code>zig</code> compiler that will be used in this post can be found <a href="https://github.com/zig-lang/zig">here</a>.</p>
<p><em>The finished conversion result is at <a href="https://github.com/tiehuis/zig-replace-c">this</a>
repository. For each heading, there is a corresponding commit which describes
all changes made at each point in the conversion process.</em></p>
<h2>The Project</h2>
<p><small><a href="https://github.com/tiehuis/zig-replace-c/commit/572d12a60187799cacb649c44b0e2a8eb7be33c7">commit</a></small></p>
<p>The project we will be replacing has the following structure:</p>
<pre><code class="language-text">$ tree .
.
├── compute.c
├── compute.h
├── compute_helper.c
├── compute_helper.h
├── display.c
├── display.h
├── main.c
└── Makefile
</code></pre>
<p>The contents of the files are:</p>
<h4>main.c</h4>
<pre><code class="language-c">#include &quot;display.h&quot;
#include &quot;compute.h&quot;

int main(void)
{
    display_char(compute('A'));
}
</code></pre>
<h4>display.c</h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void display_char(char c)
{
    printf(&quot;%c\n&quot;, c);
}
</code></pre>
<h4>compute.c</h4>
<pre><code class="language-c">#include &quot;compute_helper.h&quot;

char compute(char a)
{
    return compute_helper(a) + 5;
}
</code></pre>
<h4>compute_helper.c</h4>
<pre><code class="language-c">char compute_helper(char a)
{
    return a + 1;
}
</code></pre>
<h4>Makefile</h4>
<pre><code class="language-make">SRCS := compute.c compute_helper.c display.c main.c
OBJS := $(SRCS:%.c=build/%.o)

main: $(OBJS)
	gcc -o main $(OBJS)

$(OBJS): build/%.o: %.c | mkdirs
	gcc -std=c99 -c $&lt; -o $@

mkdirs:
	@mkdir -p build

clean:
	rm -rf build main
</code></pre>
<p>The <code>.h</code> file contents simply expose their corresponding <code>.c</code> implementations.</p>
<pre><code class="language-text">$ make
gcc -std=c99 -c compute.c -o build/compute.o
gcc -std=c99 -c compute_helper.c -o build/compute_helper.o
gcc -std=c99 -c display.c -o build/display.o
gcc -std=c99 -c main.c -o build/main.o
gcc -o main build/compute.o build/compute_helper.o build/display.o build/main.o

$ ./main
G
</code></pre>
<h2>The Zig Build System</h2>
<p><small><a href="https://github.com/tiehuis/zig-replace-c/commit/0704b4455bc23f1dae820fe2791dcc56368e7aaa">commit</a></small></p>
<p>The first thing we will change is replacing the <code>Makefile</code> with zigs own custom
build system. The build system of zig is written in zig itself, which reduces
the requirement of knowing the oft-arcane Makefile idiosyncrasies.</p>
<h4>build.zig</h4>
<pre><code class="language-text">const Builder = @import(&quot;std&quot;).build.Builder;

pub fn build(b: &amp;Builder) {
    const exe = b.addCExecutable(&quot;main&quot;);
    exe.addCompileFlags([][]const u8 {
        &quot;-std=c99&quot;
    });

    const source_files = [][]const u8 {
        &quot;compute.c&quot;,
        &quot;compute_helper.c&quot;,
        &quot;display.c&quot;,
        &quot;main.c&quot;
    };

    for (source_files) |source| {
        exe.addSourceFile(source);
    }

    exe.setOutputPath(&quot;./main&quot;);
    b.default_step.dependOn(&amp;exe.step);
}
</code></pre>
<p>First, we begin by specifying the main executable which we will be building.
This constructs an object which represents a build-step. For each source
file in our project, we simply add the file to main executable step.</p>
<p>This approach is far more imperative than the declarative approach of a
Makefile. In my view, this is a good choice. Makefiles whilst concise can
become exceedingly opaque and hard to parse, especially as a project grows and
extra conditions need to be handled.</p>
<pre><code class="language-text">$ zig build --verbose
cc -c compute.c -o zig-cache/compute.c.o -std=c99
cc -c compute_helper.c -o zig-cache/compute_helper.c.o -std=c99
cc -c display.c -o zig-cache/display.c.o -std=c99
cc -c main.c -o zig-cache/main.c.o -std=c99
cc zig-cache/compute.c.o zig-cache/compute_helper.c.o zig-cache/display.c.o \
    zig-cache/main.c.o -o main -Wl,-rpath,zig-cache -rdynamic

$ ./main
G
</code></pre>
<h2>First C Replacement</h2>
<p><small><a href="https://github.com/tiehuis/zig-replace-c/commit/c74cba439b36fa7f6de41a155f156c06083bccfb">commit</a></small></p>
<p>The first actual source code we will replace is <code>compute.c</code>.</p>
<h4>compute.zig</h4>
<pre><code class="language-text">use @cImport(@cInclude(&quot;compute_helper.h&quot;));

export fn compute(a: u8) -&gt; u8 {
    compute_helper(a) + 5
}
</code></pre>
<p>This snippet demonstrates a few features of zig. First, zig is able to parse
C header files directly. No binding interface needing! In this case, the <code>use</code>
statement will bring all definitions from <code>compute_helper.h</code> into the global
namespace, allowing us to call the <code>compute_helper</code> function.</p>
<p>The other important thing to note here is the <code>export</code> specifier on our function.
This is important as it tells zig that it should compile this against the C ABI.
This means we can call this function from within other C files.</p>
<p>Since our header files are simple, we can continue using them unmodified. Zig does
automatically generate C headers as well however. We can compare these against
the expected definitions to make sure that we implemented the function
correctly.</p>
<h4>zig-cache/compute.zig.h</h4>
<pre><code class="language-c">#ifndef COMPUTE_2E_ZIG_H
#define COMPUTE_2E_ZIG_H

#include &lt;stdint.h&gt;

#ifdef __cplusplus
#define COMPUTE_2E_ZIG_EXTERN_C extern &quot;C&quot;
#else
#define COMPUTE_2E_ZIG_EXTERN_C
#endif

#if defined(_WIN32)
#define COMPUTE_2E_ZIG_EXPORT COMPUTE_2E_ZIG_EXTERN_C __declspec(dllimport)
#else
#define COMPUTE_2E_ZIG_EXPORT COMPUTE_2E_ZIG_EXTERN_C __attribute__((visibility (&quot;default&quot;)))
#endif

COMPUTE_2E_ZIG_EXPORT uint8_t compute(uint8_t a);
COMPUTE_2E_ZIG_EXPORT __attribute__((__noreturn__)) void __zig_panic(const uint8_t * message_ptr, uintptr_t message_len);

#endif
</code></pre>
<h3>Build System Modification</h3>
<p>The second step we need to perform is modifying <code>build.zig</code> to compile both
C and zig files and link them together.</p>
<h4>build.zig</h4>
<pre><code class="language-text">const Builder = @import(&quot;std&quot;).build.Builder;

pub fn build(b: &amp;Builder) {
    const exe = b.addCExecutable(&quot;main&quot;);
    b.addCIncludePath(&quot;.&quot;);
    exe.addCompileFlags([][]const u8 {
        &quot;-std=c99&quot;
    });

    const source_files = [][]const u8 {
        &quot;compute_helper.c&quot;,
        &quot;display.c&quot;,
        &quot;main.c&quot;
    };

    for (source_files) |source| {
        exe.addSourceFile(source);
    }

    const zig_source_files = [][]const u8 {
        &quot;compute.zig&quot;,
    };

    for (zig_source_files) |source| {
        const object = b.addObject(source, source);
        exe.addObject(object);
    }

    exe.setOutputPath(&quot;./main&quot;);
    b.default_step.dependOn(&amp;exe.step);
}
</code></pre>
<p>This is mostly same, except we now have a list of zig source files as well. This
should be fairly self-explanatory; for each zig source, we create an object
build step. This is then added to the exe build step.</p>
<p>Note that we also add the current directory to the C include path. This is
important since the <code>@cInclude</code> function used by zig does not read headers from
the local directory.</p>
<pre><code class="language-text">$ zig build --verbose
zig build-obj compute.zig --cache-dir zig-cache --output zig-cache/compute.zig.o \
    --output-h zig-cache/compute.zig.h --name compute.zig -isystem .
cc -c compute_helper.c -o zig-cache/compute_helper.c.o -std=c99 -I zig-cache
cc -c display.c -o zig-cache/display.c.o -std=c99 -I zig-cache
cc -c main.c -o zig-cache/main.c.o -std=c99 -I zig-cache
cc zig-cache/compute.zig.o zig-cache/compute_helper.c.o zig-cache/display.c.o \
    zig-cache/main.c.o -o main -Wl,-rpath,zig-cache -rdynamic

$ ./main
G
</code></pre>
<h2>Using the Zig Standard Library</h2>
<p><small><a href="https://github.com/tiehuis/zig-replace-c/commit/8a8f571d7802dd416b81269830ccd7313b810b51">commit</a></small></p>
<p>The next file we will replace is <code>display.c</code>.</p>
<h4>display.zig</h4>
<pre><code class="language-text">const std = @import(&quot;std&quot;);
const printf = std.io.stdout.printf;

export fn display_char(c: u8)
{
    %%printf(&quot;{c}\n&quot;, c);
}
</code></pre>
<p>Since we want to end up using only zig, we can replace the C printf statement
with zig’s own stdlib implementation. Zig does not depend on libc at all.
Because this is the only use of libc in our project, we can use the <code>nostdlib</code>
to enforce this during our C compilation.</p>
<h4>build.zig</h4>
<pre><code class="language-text">exe.addCompileFlags([][]const u8 {
    &quot;-std=c99&quot;,
    &quot;-nostdlib&quot;,
});
</code></pre>
<p>The only other changes are removing <code>display.c</code> from the C sources, and adding
<code>display.zig</code> to the zig sources.</p>
<pre><code class="language-text">$ zig build --verbose
zig build-obj compute.zig --cache-dir zig-cache --output zig-cache/compute.zig.o \
    --output-h zig-cache/compute.zig.h --name compute.zig -isystem .
zig build-obj display.zig --cache-dir zig-cache --output zig-cache/display.zig.o \
    --output-h zig-cache/display.zig.h --name display.zig -isystem .
cc -c compute_helper.c -o zig-cache/compute_helper.c.o -std=c99 -nostdlib -I zig-cache -I zig-cache
cc -c main.c -o zig-cache/main.c.o -std=c99 -nostdlib -I zig-cache -I zig-cache
cc zig-cache/compute.zig.o zig-cache/display.zig.o zig-cache/compute_helper.c.o \
    zig-cache/main.c.o -o main -Wl,-rpath,zig-cache -rdynamic

$ ./main
G
</code></pre>
<h2>Removing Header Files</h2>
<p><small><a href="https://github.com/tiehuis/zig-replace-c/commit/e24d3141956521f7c950ce8ff8a48e6210fe2e4e">commit</a></small></p>
<p>As we get further along in our replacement, we will eventually reach the point
where we have zig files which are not used by any other C files. This is great
as it means we can remove the header files.</p>
<p>Consider now as we change <code>compute_helper.c</code>.</p>
<h4>compute_helper.zig</h4>
<pre><code class="language-text">pub fn compute_helper(a: u8) -&gt; u8
{
    a + 1
}
</code></pre>
<p>The only dependency on this is <code>compute.zig</code>. We don’t need to export this using
the C ABI and can just mark it <code>pub</code> for visibility. <code>compute.c</code> can then be
changed to import a zig file instead.</p>
<h4>compute.zig</h4>
<pre><code class="language-text">pub use @import(&quot;compute_helper.zig&quot;);

export fn compute(a: u8) -&gt; u8 {
    compute_helper(a) + 5
}
</code></pre>
<pre><code class="language-text">$ zig build --verbose
zig build-obj compute.zig --cache-dir zig-cache --output zig-cache/compute.zig.o \
    --output-h zig-cache/compute.zig.h --name compute.zig -isystem .
zig build-obj compute_helper.zig --cache-dir zig-cache --output zig-cache/compute_helper.zig.o \
    --output-h zig-cache/compute_helper.zig.h --name compute_helper.zig -isystem .
zig build-obj display.zig --cache-dir zig-cache --output zig-cache/display.zig.o \
    --output-h zig-cache/display.zig.h --name display.zig -isystem .
cc -c main.c -o zig-cache/main.c.o -std=c99 -nostdlib -I zig-cache -I zig-cache -I zig-cache
cc zig-cache/compute.zig.o zig-cache/compute_helper.zig.o zig-cache/display.zig.o \
    zig-cache/main.c.o -o main -Wl,-rpath,zig-cache -rdynamic

$ ./main
G
</code></pre>
<h2>The Final File</h2>
<p><small><a href="https://github.com/tiehuis/zig-replace-c/commit/1bbee329aebbbb8578623d4b8e1967904fa6dcb1">commit</a></small></p>
<p>Our project now has only 1 remnant left of C. Let’s remove it all!</p>
<h4>main.zig</h4>
<pre><code class="language-text">use @import(&quot;display.zig&quot;);
use @import(&quot;compute.zig&quot;);

pub fn main() -&gt; %void {
    display_char(compute('A'));
}
</code></pre>
<p>The main things to note here are the <code>use</code> statements for import. Since we were
converting a C project, we didn’t initially have any namespacing. Since zig has
a proper module system we usually strongly prefer assigning our imports to a
constant. e.g. <code>const display = @import(&quot;display.zig&quot;)</code>.</p>
<p>Now, we need to edit our <code>build.zig</code> file.</p>
<h4>build.zig</h4>
<pre><code>const Builder = @import(&quot;std&quot;).build.Builder;

pub fn build(b: &amp;Builder) {
    const exe = b.addExecutable(&quot;main&quot;, &quot;main.zig&quot;);

    exe.setOutputPath(&quot;./main&quot;);
    b.default_step.dependOn(&amp;exe.step);
}
</code></pre>
<p>Much simpler! Zig can make use of the implicit dependency graph formed between
imports. Individual object files do not need to be built for each file
explicitly.</p>
<pre><code class="language-text">$ zig build --verbose
zig build-exe main.zig --cache-dir zig-cache --output main --name main

./main
G
</code></pre>
<h2>Closing</h2>
<p>Zig makes this type of iterative conversion comparatively easier than most other
languages. For larger projects there will be unknown difficulties however. These
will be continually improved as the language becomes more stable and refined.</p>
<p>Being able to easily replace C with a newer modern alternative is a real bonus
in terms of safety and ergonomics. See this
<a href="http://andrewkelley.me/post/intro-to-zig.html">post</a> by the creator of the
language some short examples of improvements.</p>
<p>If you want to know more about zig as a language, check out the <a href="http://ziglang.org/">project
page</a>.</p>
    </div>

    <div class="footer">
      <a href="/">home</a> - <a href="https://github.com/tiehuis/">github</a> <!-- - <a href="/feed.xml">rss</a> --> <br/>
    </div>
  </body>
</html>
